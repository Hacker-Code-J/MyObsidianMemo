
```c
#include <Cstdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 100000
#define MAX_A 1000000

int spf[MAX_A + 1];

void sieve() {
    for (int i = 1; i <= MAX_A; i++) spf[i] = i;
    for (int i = 4; i <= MAX_A; i += 2) spf[i] = 2;
    for (int i = 3; i * i <= MAX_A; i++) {
        if (spf[i] == i) {
            for (int j = i * i; j <= MAX_A; j += i) {
                if (spf[j] == j) spf[j] = i;
            }
        }
    }
}

int distance(int a, int b) {
    int *countA = (int*)calloc(MAX_A + 1, sizeof(int));
    int *countB = (int*)calloc(MAX_A + 1, sizeof(int));

    while (a != 1) {
        countA[spf[a]]++;
        a /= spf[a];
    }

    while (b != 1) {
        countB[spf[b]]++;
        b /= spf[b];
    }

    int dist = 0;
    for (int i = 2; i <= MAX_A; i++) {
        dist += abs(countA[i] - countB[i]);
    }

    free(countA);
    free(countB);

    return dist;
}

int main() {
    int n;
    scanf("%d", &n);

    int *numbers = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        scanf("%d", &numbers[i]);
    }

    sieve();

    for (int i = 0; i < n; i++) {
        int minDist = MAX_A;
        int minIndex = -1;

        for (int j = 0; j < n; j++) {
            if (i != j) {
                int dist = distance(numbers[i], numbers[j]);
                if (dist < minDist) {
                    minDist = dist;
                    minIndex = j;
                }
            }
        }
        printf("%d\n", minIndex + 1); // +1 for 1-based indexing
    }

    free(numbers);
    return 0;
}
```