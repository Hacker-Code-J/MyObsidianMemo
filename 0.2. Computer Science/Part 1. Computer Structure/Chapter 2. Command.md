
[[Computer Structure]]

# 소스코드에서 명령어로

소스 코드: 사람(개발자)가 이해하기 편한 언어 (고급 언어)
명령어와 데이터: 컴퓨터가 이해하기 편한 언어 (저급 언어)

즉, 고급 언어로 작성된 소스 코드는 내부적으로 저급 언어로 구성된 명령어와 데이터로 변환된다.

저급 언어
- 기계어 (Machine Code)
- 어셈블리어 (Assembly Language)

고급 언어에서 저급 언어로 변환되는 대표적 방식
- 컴파일
- 인터프린트

컴파일
- 소스 코드 전체가 컴파일러(gcc, clong, visual studio)에 의해 검사, 목적 코드로 변환
- C/C++, Rust
- 소스 코드 (고급 언어) -> 컴파일러(컴파일) -> 목적 코드(저급 언어)

인터프린트
- 소스 코드 한 줄 씩 인터프린터에 의해 검사, 목적 코드로 변환
- Python, JavaScript

오개념 주의
- 소스 코드가 저급 언어로 변환되는 대표적인 방식일 뿐 컴파일 방식과 인터프린트 방식은 칼로 자르듯 구분되는 개념은 아니다.
- 컴파일 언어의 특성과 인터프린트 언어의 특성을 모두 갖춘 언어도 있다. (Java, Python)

# 컴파일 - 명령어 관찰하기

https://godbolt.org/

```c
#include <stdio.h>
int main() {
	int a = 1;
	int b = 2;
	int c = a + b;
	printf("%d\n", c);
	return 0;
}
```

```assembly (x86-64 gcc 11.4)
.LC0:
	.string "%d\n"
main:
	push rbp
	mov rbp, rsp
	sub rsp, 16
	mov DWORD PTR [rbp-4], 1
	mov DWORD PTR [rbp-8], 2
	mov edx, DWORD PTR [rbp-4]
	mov eax, DWORD PTR [rbp-8]
	add eax, edx
	mov DWORD PTR [rbp-12], eax
	mov eax, DWORD PTR [rbp-12]
	mov esi, eax
	mov edi, OFFSET FLAT:.LC0
	mov eax, 0
	call printf
	mov eax, 0
	leave
	ret
```

```zsh
$ gcc --version
$ cat hello.c
$ gcc -o hello hello.c 
$ gcc -S hello.c -o hello.S
$ cat hello.S
```

# 명령어 구조

 명령어
 - "밥을 드세요"
 - "이 상자를 저기로 옮겨라"
 - "받들어 총"

명령어
- 무엇을 대상으로 무엇을 수행하라.
- 더해라 | 100과 | 120을
- 빼라 | 메모리 32번지 안의 값과 | 메모리 33번지 속의 값을
- 저장해라 | 무엇을 | 메모리 128번지에
- 출력해라 | 무엇을 | 모니터에

명령어
- 연산 코드 (Op Code) | 오퍼랜드
- 오퍼랜드로 연산 코드를 수행하라.
- 피연산자, 오퍼랜드(operand): 명령어를 수행할 대상
	- 대상(데이터)이 직접 명시되기도 하고, **대상의 위치**(레지스터 이름, 메모리 주소)가 명시되기도 함.
- 연산코드(op-code): 오퍼랜드로 수행할 동작
- n-주소 명령어, n=0,1,2,...
- 2-주소 명령어로 X=(A+B) * C 계산하기
	1. R1<-M(A): 메모리의 A 번지 값을 연산을 진행할 레지스터 R1을 옮깁니다.
	2. ....
	3. ...
	4. ...
- 3-주소 명령어로 X=(A+B) * C 계산하기
	1. ...
	2. 2...



# 주소 지정

왜 데이터를 직접 명시하지 않고 위치를 명시하는 걸까? -> 명령어의 길이가 제한되어 있다.

유효 주소
- 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치

주소 지정
- 유효 주소를 찾는 방법
- CPU 마다 차이가 있다.

주소 지정 방식
	1. 즉시 주소 지정
	2. 직접 주소 지정
	3. 간접 주소 지정
	4. 레지스터 주소 지정
	5. 레지스터 간접 주소 지정

1. 즉시 주소 지정
	- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
	- 가장 빠른 주소 지정 + 데이터 크기 제한
	- 연산 코드 | 연산 코드에 사용될 데이터
2. 직접 주소 지정
	- 오퍼랜드 필드에 유효 주소(연산에 사용될 데이터가 저장된 메모리 주소) 명시
	- 오퍼랜드 필드로 표현 가능한 메모리 주소 크기에 제한
	- 연산 코드 | 메모리 주소
	- CPU의 접근 속도 차이: **레지스터 > 메모리**
3. 간접 주소 지정
	- 오퍼랜드 필드에 유효 주소의 주소 명시
	- 유효 주소 크키에 제한은 없으나, 속도가 비교적 느림
	- 연산 코드 | 유효 주소의 주소
4. 레지스터 주소 지정
	- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
	- 레지스터 접근은 메모리보다 빠르다
	- 연산 코드 | 레지스터 주소
5. 레지스터 간접 주소 지정
	- 연산에 사용할 데이터를 메모리에 저장하고,
	- 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
	- 메모리 접근은 한 번

